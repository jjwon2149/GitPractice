#  챕터 6 -  스위프트 연산자와 표현식

---
### 6.1 - 스위프트 표현식(Expression) 구문
* 하나의 ``연산자``(Operator), 두 개의 ``피연산자``(operand), ``할당자``(assignment)로 구성된다
* 4가지 표현 식이 있다 
  * 접두사 표현식
  * 중위 표현식
  * 으뜸 표현식
  * 접미사 표현식
* 표현 식은 수행하면 값을 반환 하거나 에러를 발생시킨다. 둘다 발생할수도 있다!

```swift
var myresult = 1 + 2
```

-   - ---
### 6.2 - 기본 할당 연산자
* 기본 할당 연산자(```=```)
* 표현 식의 결과를 변수,상수에 저장하는 역할을 한다.
* 두 개의 피 연산자를 받는다. ``피 연산자 1 = 피 연산자 2``
  * 왼쪽의 피 연산자(할당 받을 대상) : 값을 할당받는 변수 또는 상수
  * 오른쪽 피 연산자(할당 할 값): 산술식, 논리 식을 수행하여 왼쪽 피 연산자에 결과를 반영

```swift
var x: Int? // 옵셔널 Int 변수 선언
var y = 10  // 두 번째 Int 변수 선언과 초기화

x = 10      // x에 값 할당
x = x! + y  // 언래핑한 x와 y의 합을 x에 할당
x = y       // y의 값을 x에 할당
```

---
### 6.3 - 산술 연산자
* 대부분 두 개의 피 연산자를 받는 ``이항 연산자``(binary operator)이다.
* 양수를 음수로 만들어주는 ``단항 연산자``(unary negative operator)는 예외적으로 하나의 연산자를 받는다.
* 두 개의 피 연산자를 받는 ``뺼셈 연산자``(subtraction operator)와 대조된다.

```swift
var x = -10 // 단항 - 연산자는 변수 x에 10을 할당하기 위해 사용함
x = x - 5 // 뺄셈 연산자. x에서 5를 뺌
```

| **연산자** | **설명**               |
|---------|----------------------|
| -(단항)   | 변수 또는 표현식의 값을 음수로 만듦 |
| *       | 곱셈                   |
| /       | 나눗셈                  |
| +       | 덧셈                   |
| -       | 뺼셈                   |
| %       | 나머지 연산               |

* 하나의 표현식 안에서 여러 개의 연산자를 사용할 수도 있다.

``` swift
x = y * 10 + z - 5 / 4
```

- ---
### 6.4 - 복합 할당 연산자
* 다른 연산자를 결합한 ``복합 할당 연산자`` (compound assignment operators) 를 제공한다.

```swift
x = x + y
```

* 단순화
```swift
x += y
```

* 복합 할당 연산자의 종류

| **연산자** | **설명**                |
|---------|-----------------------|
| x += y  | x와 y를 더한 결과를 x에 저장한다  |
| x -= y  | x에서 y를 뺀 결과를 x에 저장한다  |
| x *= y  | x와 y를 곱한 결과를 x에 저장한다  |
| x /= y  | x를 y로 나눈 결과를 x에 저장한다  |
| x %= y  | x를 y로 나눈 나머지를 x에 저장한다 |

---
### 6.5 - 비교 연산자
* 두 개의 피 연산자를 가지고 비교한 결과에 따라 불리언 결과를 반환한다.
* 두 개의 피 연산자를 가지고 작업한다는 점에서 ``이항연산자``  이라고 한다.

```swift
if x == y {
	//print("값이 일치합니다")
}
```

```swift
var result: Bool? 
var x = 10
var y = 20

result = x < y
```

* 비교 연산자의 종류

| **연산자** | **설명**                    |
|---------|---------------------------|
| x == y  | x와 y가 같다면 true를 반환한다.     |
| x > y   | x가 y보다 크다면 true를 반환한다.    |
| x >= y  | x가 y보다 크거나 같다면 true를 반환한다 |
| x < y   | x가 y보다 작다면 true를 반환한다     |
| x <= y  | x가 y보다 작거나 같다면 true를 반환한다 |
| x != y  | x가 y와 같지 않다면 true를 반환한다   |

---
### 6.6 - 불리언 논리 연산자
* 논리 연산자 (Logical operators) 는 부울 로직 값을 ```true``` 와 ```false``` 로 수정하거나 결합한다. Swift는 C-기반 언어에서 볼 수 있는 3개의 표준 논리 연산자를 제공한다.
* ``NOT(!), AND(&&), OR(||)``  연산자가 있다.
* 논리적 NOT 연산자(Logical Not Operator)
  * 논리적 NOT 연산자 (logical NOT operator) (``!a``)는 부울 값을 ```true``` 를 ```false``` 로 ```false``` 를 ```true``` 와 같이 반대로 만든다.

```swift
var flag = true   // flag는 true이다
var secondFlag = !flag  //secondFlag는 flase가 저장된다
```
    
* 논리적 AND 연산자 (Logical AND Operator)
  * 논리적 AND 연산자 (logical AND operator) (```a && b```)는 두 값이 모두 ```true```여야 ```true``` 를 표현하는 논리적 표현식을 만든다.
  * 두 값중 하나라도 ```false```이면 결과는 ```false``` 이다. 
  * 첫번째 값이 ```false``` 이면 ```true``` 의 결과를 얻을 수 없기 때문에 두번째 값은 살펴보지 않는다. 이러한 경우를 ```연산 생략``` (short-circuit evaluation) 이라 한다.

```swift
if (10 < 20) && (20 < 10) {
	print("Expression is true")
}
```

* 논리적 OR 연산자 (Logical OR Operator)
  * 논리적 OR 연산자 (logical OR operator) (```a || b```)는 2개의 인접한 파이프 문자(```|```)로 만들어진 중위 연산자 (infix operator)이다  
  * 두 값 중 하나라도 ```true``` 이면 표현 식이 ```true``` 가 되는 논리적 표현 식을 만든다
  * ``연산 생략``(short-circuit evaluation)을 사용하여 표현식을 고려한다. 
  * 논리적 OR 연산자의 좌변이 ``true`` 이면 표현 식의 결과는 바뀌지 않으므로 우변은 고려하지 않는다.

```swift
if (10 < 20) || (20 < 10) {
	print("Expression is true")
}
```

---
### 6.7 - 범위 연산자
* 숫자의 범위를 간단하게 표시할때 사용한다
* 오름 차순 형식으로 사용해야한다
* 실수의 형식으로도 사용이 가능하지만 보통은 정수형식으로 사용한다
* 닫힌 범위연산자(Closed range operator)
  * 콤마 3개 ``…``를 사용한다
  
  ```swift
  	x...y     
  ```
  
* 반 개방 범위 연산자(Half-open range operator)
  * 콤마 2개 ``..``와 ``비교 연산자``를 사용한다
  
  ```swift
  	x..<y
  
  ```

* 단방향 범위 연산자(One-sided range operator)
  * 콤마 3개``…``를 사용한다
  * 닫힌 범위연산자와 다르게 한 방향이다.
  
```swift
	x...
	...y
```
  
---
### 6.8 - 삼항 연산자
* 삼 항 연산자는 조건의 값을 기반으로 주어진 두 개의 값 중 하나로 나타낸다. 
* 간단한 조건문을 간결하게 사용하고 싶을때 사용한다

```swift
조건문 ? 참(true)인 경의의 표현식 : 거짓(false)인 경우의 표헌식 
```

```swift
let a = b > 10 ? true : false
// b가 10보다 크면 a에 true 할당
// b가 10보다 작으면 a에 false 할당
```

---
### 6.9 - nil 병합 연산자
* nil coalescing operator 라고 한다
* nil을 하나로 합친다 라고 생각하면 될 것 같다.
* ``if-let, guard-let 바인딩``에 비해 한줄로 쓸수있는 장점이 있다
* 옵셔널 변수 ?? nil 일 경우 행동한다
* 옵셔널 값이 nil이 아니라면 옵셔널 값을 일반 값으로 가공시켜준다 (``언래핑``)
  * if-let 바인딩
  
```swift
let a : Int? = 10
var b : Int

if let a = a {
	b = a
	print(b)
}
```

* ``??``을 사용한다
  * nil 병합 연산자
```swift
let a : Int? = 10
var b : Int

b = a ?? 0

print(b)
```
	
```swift
let customerName: String? = nil
print("Welcome back, \(customerName ?? "customer")")
// nil 이기떄문에 customer 출력

let customerName: String? = "John"
print("Welcome back, \(customerName ?? "customer")")
// nil이 아니기 때문에 John 출력
```

---
### 6.10 - 비트 연산자
* 메모리 ``비트(bit)단위``로 직접적인 논리 연산을 하거나, 비트 단위 이동시에 사용하는 연산자
* 컴퓨터 프로세스는 2진수로 작동한다  ``비트(bit)``라고 부르는 연속된 0과 1이다
* 비트 8개가 모이면 ``1바이트(byte)``가 된다.
* 코드에서 비트연산을 쉽게 할 수 있도록 ``비트연산자(Bit operator)``를 제공한다
  * 비트연산자
  
| 사용기호 | 용어                           | 예시                                                           |
|------|------------------------------|--------------------------------------------------------------|
| ~    | Bitwise NOT Operator         | 단항 연산자로 사용,  기존 메모리 비트를``반전``시킨다.<br>``( 0 -> 1 , 1 -> 0)``  |
| &    | Bitwise AND Operator         | 두개의 메모리 비트 중 ``모두가 1이면 1을 반환한다``<br>``(true && true)``       |
| \|   | Bitwise OR Operator          | 두개의 메모리 비트중 ``하나라도 1이면 1을 반환한다<br>``(true \\\\\\\|\\\\\\\| true)`` |
| ^    | Bitwise XOR Operator         | 두개의 메모리 비트 중 둘을 비교해서 ``서로 다르면 1을 반환하고 서로 같으면 0을 반환``         |
| <<   | Bitwise Left Shift Operator  | 모든 비트를 원하는 값 만큼 ``왼쪽으로 이동시킨다``<br>부호여부 상관 X,  2를 곱하는 것 같다.   |
| >>   | Bitwise Right Shift Operator | 모든 비트를 원하는 값 만큼 ``오른쪽으로 이동시킨다``<br>부호가 있을경우는 주의해야한다(``산술시프트``)<br>2를 나누는것과 같다 |
### 6.10.1 - NOT 비트 연산
* ``NOT은 틸트(-)``문자로 표현되며 숫자의 모든 비트를 반대로 만든다.
* ``0 -> 1 , 1 -> 0`` 으로 만든다.

```swift
00000011 NOT
============
11111100
```
	
```swift
let y = 3
let z = ~y
print("Result is \(z)")     // 값은 -4
```

### 6.10.2 - AND 비트 연산
* ``AND는 앰퍼샌드(&)``문자로 표현되며, 두 개의 숫자를 비트 단위로 비교한다.
* 두 숫자의 2진수를 가지고 서로 해당하는 위치의 비트가 1이면 1이고, 위치의 비트 값이  다르다면 0이다.

```swift
10101011 AND
00000011
========
00000011
```

```swift
let x = 171
let y = 3
let z = x & y

print("Result is \(z)")    //값은 3
```

### 6.10.3 - OR 비트 연산
* 두 개의 2진수를 비트 단위로 비교하는 작업을 한다.
* ``AND 연산``과 다르게 ``OR``은 두개의 피 연산자 중 하나라도 1이 있으면 1의 결과를 나타낸다
* 하나의 ``수직바(|)``로 표현된다

```swift
10101011 OR
00000011
========
10101011
```

```swift
let x = 171
let y = 3
let z = x | y

print("Result is \(z)")   //값은 171
```

### 6.10.4 - XOR 비트 연산
* 일반적으로 ``베타적 논리합``이라고 부른다.
* ``캐럿(^)`` 문자로 표현된다.
* ``OR``연산과 비슷하나 두개의 비트중 ``하나만`` 1일 경우에 1이 된다.
* 두개의 비트가 모두 1이거나 0이면 해당 비트는 0으로 설정된다

```swift
10101011 XOR
00000011
========
10101000
```

```swift
let x = 171
let y = 3
let z = x ^ y

print("Result is \(z)")   //값은 168
```

### 6.10.5 - 왼쪽 시프트 비트 연산
* 왼쪽 시프트 비트 연산은 2진수의 각 비트를 지정된 횟수만큼 ``왼쪽으로 이동``시킨다
* 왼쪽으로 이동하면 ``값은 2배``가 된다
* 왼쪽으로 이동함에 따라 ``맨 오른쪽은 0``으로 채워진다
* 이동 했을 때 값을 담는 ``변수의 크기를 넘으면 값은 무시``되어 버려진다

```swift
10101011 1비트 왼쪽 시프트
========
101010110
```

```swift
let x = 171
let z = x << 1

print("Result is \(z)")  //값은 342
```

### 6.10.6 - 오른쪽 시프트 비트 연산
* 오른쪽 시프트 비트 연산은 2진수의 각 비트를 지정된 횟수만큼 ``오른쪽으로 이동``시킨다
* 오른쪽으로 이동하면 ``값은 절반``이 된다
* 오른쪽으로 이동시키기 때문에  오른쪽 끝 자리는 없게 되어 ``마지막 비트는 폐기``된다
* 최상위 비트에 1을 둘지 0을 둘지는 양수,음수를 가르키는 ``부호비트(Sign bit)``가 설정 되었는지에 따라 결정된다.

```swift
10101011 1비트 오른쪽 시프트
========
01010101
```

```swift
let x = 171
let z = x >> 1

print("Result is \(z)") //값은 85
```

---
### 6.11 - 복합 비트 연산자
* 산술 연산자 처럼 각각의 비트연산자는 하나의 연산자를 이용하여 비트 연산을 하고 그 결과를 할당하는 연산자를 가지고 있다.

| 연산자     | 설명                                   |
|---------|--------------------------------------|
| x &= y  | x와 y의 AND 비트 연산을 하고  그 결과를 x에 할당한다   |
| x != y  | x와 y의 OR 비트 연산을 하고 그 결과를 x에 할당한다     |
|  x ~= y | x와 y의 XOR 비트 연산을 하고 그 결과를 x에 할당한다    |
| x <<= n | x를 n번 왼쪽 시프트 비트연산을 하고 그 결과를 x에 할당한다  |
| x >>= n | x를 n번 오른쪽 시프트 비트연산을 하고 그 결과를 x에 할당한다 |
