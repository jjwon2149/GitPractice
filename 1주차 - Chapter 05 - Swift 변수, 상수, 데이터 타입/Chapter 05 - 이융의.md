# Chapter 05 - 스위프트 데이터 타입, 상수, 그리고 변수
<!-- 
## 5.2 - 데이터 타입
</br>

### Int
- 정수(부호있는 정수와 부호없는 정수)
- Int8, Int6, Int32, Int64
- UInt8, UInt16, UInt32, UInt64

***일반적으로는 플랫폼에 맞는 정수 크기를 사용하게 하는 Int 타입을 사용한다.***


</br>
</br>

### Float, Double

소수점이 있는 값 (ex. 4353.1223)
- Float (최대 32비트, 6자리까지 제공)
- Double (최대 64비트, 15자리까지 제공)
</br>
</br>

### Boolean
참/거짓(1과 0)
- true
- false
</br>
</br>

### Character
하나의 문자(문자, 숫자, 문장 부호, 기호 등)
</br>
</br>

### String
단어나 문장
> 문자열 보간법 https://www.hackingwithswift.com/read/0/5/string-interpolation

</br>
</br>

### 특수 문자/이스케이프 시퀀스

- 이스케이프 시퀀스: 개행, 탭 또는 문자열 내에 특정 유니코드 값을 지정하는 특수 문자
- 이스케이핑: 이러한 특수 문자를 \(역슬래시)로 구별하는 것

```swift
var newLine = "\n"
```

</br></br></br>

---

### 5.3 - 변수
애플리케이션이 사용하는 데이터를 저장하기 위해 예약된 컴퓨터 메모리 내의 위치
값 변경 가능

### 5.4 - 상수
한 번 할당 되면 값 변경 불가능

### 5.5 - 상수와 변수
- 변수보다 상수를 사용한는 것이 성능 향상에 도움


### 5.6 - 타입 애너테이션/타입 추론
- type safe - 변수의 데이터 타입이 한 번 정해지면 그 변수는 다른 타입의 데이터를 저장하는 데 사용 x

- 타입 애너테이션 (변수 및 상수 선언 시 타입을 지정하는 것)

```swift
var userCount: Int = 0
```

- 타입 추론 ( )

### 5.7 - 생략 -->


## 5.8 Optional

- 값이 '있을 수도, 없을 수도 있음'을 나타내는 표현
- 변수나 상수에 꼭 값이 있다는 것을 보장 못함
- 즉 값이 nil 일 수 있다.

목적: 변수, 상수에 값이 할당되지 않은 상황을 처리하기 위해 안전하고 일관된 접근 방식을 제공

```swift
var name: String?     // nil
```

</br>

***옵셔널의 값을 옵셔널이 아닌 값으로 추출하는 방법***

1. 강제 추출
    * 가장 간단하지만 가장 위험한 방법
    * 강제 추출 시 옵셔널에 값이 없다면, 즉 nil 이라혐 런타임 오류가 발생한다.

</br>

2. 옵셔널 바인딩
    * if, while 구문 등과 결합하여 사용

```swift
var myName: String? = "iyungui"

if let name = myName {
    print("My name is \(name)")
} else {
    print("myName == nil")
}
// My name is iyungui
```

> name 은 if 구문 안에서만 사용하는 임시 상수/변수

</br>
</br>
</br>

또는 아래 코드 처럼 임시 값의 사용을 하지 않아도 된다.


***if - let 구문***

```swift
var myName: String? = "iyungui"

if let myName {
    print("My name is \(name)")
} else {
    print("myName == nil")
}

```


</br>
</br>

3. 암시적 추출 옵셔널
- 타입 뒤에 ! 를 사용.
- 암시적 추출 옵셔널로 지정된 타입은 일반 값처럼 사용할 수 있으나, 여전히 옵셔널이기에 nil 할당 가능

</br>

-> ***강제추출, 암시적 추출 옵셔널 보다는 옵셔널 바인딩, 옵셔널 체이닝을 사용하는 것이 안전하다.***


</br>
</br>

---

## 5.9 타입 캐스팅과 타입 검사

- 컴파일러가 어떤 값의 특정 타입을 식별하지 못하는 경우
- 메서드, 함수가 반환하는 값이 불명확하거나 예상되지 않은 타입의 값일 때 발생

이럴 때는 as 키워드를 사용하여 내가 의도한 타입을 컴파일러가 알 수 있게 해야 한다. 이것을 ***타입 캐스팅(형 변환)*** 이라고 한다.

</br>

### 타입 캐스팅의 용도

- 타입 검사 (Type Checking): 특정 인스턴스가 어떤 클래스 또는 클래스의 자식 클래스의 인스턴스인지 확인한다. 이는 is 키워드로 수행된다.
- 타입 캐스팅 (Type Casting): 인스턴스를 부모 또는 자식 클래스 타입으로 취급해야 할 때 사용된다. Swift에서는 as? 또는 as! 연산자를 사용하여 타입 캐스팅을 한다.

</br>


### 타입 캐스팅의 종류

- ***업캐스팅 (Upcasting)***
    - 서브 클래스의 인스턴스를 슈퍼 클래스 타입으로 취급하는 경우
    - 업캐스팅은 항상 안전하기 때문에 as 연산자를 사용하거나 자동으로 수행된다. 
    - 업캐스팅은 상위 타입의 인터페이스만 접근할 수 있게 한다.

```swift
class Animal {}
class Dog: Animal {}

let pet = Dog()
let animal: Animal = pet // 업캐스팅
```

</br>

- ***다운캐스팅 (Downcasting)***
    - 슈퍼 클래스의 인스턴스를 서브 클래스 타입으로 취급하는 경우
    - 다운캐스팅은 불확실할 수 있기 때문에 as? 또는 as! 연산자로 수행해야 한다. 
    - as?는 실패할 수 있는 다운캐스팅(옵셔널 반환)을, as!는 실패할 수 없다고 확신할 때 사용하는 강제 다운캐스팅(크래시 발생 가능)을 의미한다.

```swift
// 옵셔널 다운캐스팅 (실패 가능성 있음)
let someAnimal: Animal = Dog()
if let dog = someAnimal as? Dog {
    print("다운캐스팅 성공!")
}

// 강제 다운캐스팅 (실패하면 런타임 에러)
let certainDog = someAnimal as! Dog
```

</br>

### 타입 캐스팅의 예

object(forKey:) 메서드가 반환하는 값을 String 타입으로 처리해야 한다고 컴파일러에게 알려주는 코드

```swift
let myValue = record.object(forKey: "comment") as! String
```

위 메서드 처럼, 종종 API는 Any 타입 등의 일반적인 타입을 반환할 수 있기에, 이 경우, 타입 캐스팅을 사용하여 컴파일러에게 명확한 타입을 알려주면 된다.

여기서 as! String은 컴파일러에게 record.object(forKey:) 메서드의 반환값이 String이라는 것을 확실히 알려주는 강제 다운캐스팅. 
</br>
이는 해당 값이 반드시 String이어야 하며, 그렇지 않은 경우 런타임 에러가 발생함을 의미한다. 
</br>
가능하다면 as?를 사용하여 안전한 다운캐스팅을 시도하고, 해당 값이 올바른 타입인지 검사하는 것이 좋다.